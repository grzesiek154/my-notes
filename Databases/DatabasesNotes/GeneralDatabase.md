

# What’s A Database?

It’s a structured system to put your data in that imposes rules upon that  data, and the rules are yours, because the importance of these problems  changes based on your needs. Maybe your problem is the *size*, while someone else has a smaller amount of data where the *sensitivity* is a high concern.

It’s the things you can’t see that are going on in the background; the  security, the enforced integrity of the data, the ability to get to it  fast and get to it reliably, the robustness; serving lots of people at  the same time and even correctly survive crashes and hardware issues  without corrupting the data.

And that’s what we need to do here; understand how to describe our  structure and define those rules, so all these invisible things will  actually happen.

# Database Management System (DBMS)

We often mistakenly say our database is *Oracle, MySQL, SQL Server, MongoDB*. But, they aren’t databases, they are database management systems (DBMS).

The DBMS is the software that would be installed on your personal computer  or on a server, then you would use it to manage one or more database.

The database has your actual data and the rules about that data, while the  DBMS is the program that surrounds and manages your actual data, and it  enforces the rules you specified on your data. The rules for example  could be the type of the data, like integer or string, or the  relationship between them.

In practice it’s very common to have multiple databases. The database that deals with your order and customer information might be completely  independent from you database that deals with human resource  information. And in many organizations, you don’t just have multiple  databases but multiple DBMS. Sometimes it’s because one DBMS is better  at something than the other.

There are different DBMS, and they are categorized under:

- Relational Database Management Systems
- Hierarchical Database Systems
- Network Database Systems
- Object-Oriented Database Systems
- NoSQL Database Systems

# Rows & Columns

Within each table, every single **row** represents one single student, customer, order, or employee. But each of these  rows is not free form. You must apply structure to this data.

So, you must say what every row is made of, and you do this by defining the **columns** in that table. And each column describes one piece of data. It gives it a **name** like *name*, *id*, *email*, *date of birth*, and a **type**, perhaps, a *text*, or a *date*, or a *number*.

Now, every row must follow that same structure, following that same format.  It’s not allowed to deviate from the way that the columns are set up.  And by defining these columns, we’re imposing rules on the data, and the DBMS won’t let us break them.

**In a nutshell,** columns define what’s the data that should be in the table, while the rows hold the actual values that you are going to *retrieve*, *insert*, *update*, and *delete*.

> You may hear the term “tuple” instead of rows, and also you may hear the term “attribute” instead of column.

# Primary Key

Now, if you have a long list of rows, it’s essential to have something that  uniquely identify each row, and that’s called the “primary key”. A  primary key is a column of unique values for each row.

You may have more than one student with the same name, but you can’t have  more than one student wit the same primary key. And if you tried to  insert a duplicate value, this will be disallowed by the DBMS.

> Usually you will see a primary key column called “id” of integer values.

The primary key is either naturally exist or generated by the DBMS. It  means, for example, by default every customer has an unique *SSN*, assigned by the company. So, the *SSN* uniquely identify every customer.

But, you may have table holds information about some products, and they  don’t have ids by nature. So, you will ask the DBMS to generate a new  unique column, like *product id* and you may want to mark it as “auto-increment”.

> Auto-increment columns allows a unique number to be generated when a new record is  inserted into a table by increment the value by 1 for each new record.

Primary keys are very important, not only to uniquely identify the rows, but  also we are going to use them to connect between the tables, and form a  relationships.

# One-to-Many Relationship

Most of your tables will be naturally be connected, so we need to have a  relationship between them. You’re not trying to invent relationships  that don’t exist, you’re trying to describe what’s already there.

An example of one-to-many relationship could be, a customer can place more than one order, but, an order is only placed by one and only one  customer. You can’t have an order that’s placed by more than one  customer.

The customer’s information exists in a table, and the order information  also exists in another table, but they have a relationship. So, “*How can we define one-to-many relationship?*”.

![Image for post](https://miro.medium.com/max/733/1*xY-atJW9j34HObJyceaV4A.png)

The values of the foreign key column could be redundant, because a customer can place more than one order. And a customer can have one, or more or  even nothing number of orders.

The benefit of defining this relationship is, it allows us to ask some questions like: “*What are the orders placed by customer who’s first name is “Smith”?*”, or go the other way, “*Who is the customer who placed the order of id 1012?*”.

# Many-to-Many Relationship

You will be using one-to-many relationship a lot between your tables. But,  there is another way to relate tables together. What if you have a  student, and each student can be enrolled in one or more courses, and at the same time, each course can have one or more students enrolled in  it.

So, it’s no longer a one-to-many, it’s many from both sides. And, as usual, the primary keys are the way to connect the tables. But, this time we  will create a new table. It’s usually called a “junction” or “linking”  table.

This table exists only to connect the two tables, it has two foreign keys,  one points to the primary key of the students table, and the second one  points to the primary key of the courses table.

And the two foreign keys together will form the primary key of the new table.

![Image for post](https://miro.medium.com/max/562/1*Sfj6qjA8noJO_OsyXP_2wA.png)

Now, using this relationship, we can know the courses of a particular  student, or go the other way and get the students who are enrolled in a  specific course.

> Officially, there is a third kind, a **one-to-one relationship** that is possible, but it’s not common.
>
> If you think about it, if one row in one table is pointing to one and only one row and another table, well, you might as well just combine those  tables so it’s one row in both places. This will be discussed later in [Database Mapping](https://medium.com/omarelgabrys-blog/af029e93cc1f).



## “Cardinality Constrains”.

These types of relationships (one-to-many, many-to-many, or one-to-one) are  usually called “Cardinality Constrains”. They are constrains that  specify the maximum participation between tables.

There are some other constrains like the “Existence Dependency Constraint”  (also called “Participation Constraint”). They specify the minimum  participation; zero (optional participation), or one or more (mandatory  participation).

> A relationship is when we say an employee “works on” a department, but,  the constrain is when we say, one employee can work in many departments

# Database Design Process

The processes here aren’t the same as the agile model, or iterative  approach. They are defined steps to end up having a fully defined  database, with it’s constrains, and the structure.

There is no place for many changes, because they are going to cost you a lot. So, you need to be specific, and take things step by step. And, here’s  the steps:

## 1. Requirements Gathering

Understanding what you want to do, and what you have is essential before you can dive into designing a database. We’ll look at the steps in this article.

## 2. Conceptual Design

We specify the entities, columns, and their relationship. We may use an  entity relationship (ER) diagram to visualize the database.

**The output is:** A conceptual schema (described using a conceptual data model like ER model).

## 3. Logical Design

It’s concerned about data model mapping; mapping a conceptual schema (like  ER model) into logical schema to provide a much detail description.

**The output is:** A logical schema (described using a logical data model specific to the DBMS like relational model).

## 4. Physical Design

It describes the details of how data is stored. You start by defining  (already modeled) tables, how the data is stored, define relationships, … in DBMS.

# Requirements Gathering

The first step in whether you are building a mobile application, desktop,  or any kind of software is to gather the requirements about what’s  actually needed. And, here are the steps:

> Take a look at [Requirements Engineering](https://medium.com/omarelgabrys-blog/requirements-engineering-introduction-part-1-6d49001526d3) in Software Engineering.

## 1. Why?, and is it feasible?

So, first you study “*Why we need a database?*”, and if it’s feasible or not. You need to check if it could be  implemented under current budget, under the current technical skills of  your team, within the defined schedule, And if it does contribute to the whole organization objectives or not.

## 2. Collecting the requirements

If the answer was Yes!, then you start collecting the requirements. You  can do this by having interviews with all the stakeholders; anyone who  will use the system.

And try to get any kind of existing data, any kind of spreadsheets, this will help you to in building the database.

And if there is an existing database, then ask, what’s wrong with it?  what’s right with it? These questions will help to avoid any of the  current problems.

## 3. Group related requirements

Now, you may need to group related requirements together, resolve any  conflicts, or any ambiguity by negotiation with the customers.

## 4. Specify & Verify the requirements

Finally, you specify the requirements, or in other words you write the  requirements in a document, and validate the requirements with the  customer to make sure that everything is on the right track.

# Database, Table & Column Names

Now you might be asking, “*What’s the best common way used to name my tables and columns?*”. Actually it depends on you, some people prefer Pascal case; upper case  first letter with singular nouns for database, tables, and columns.

And some other prefer the lower case letters with underscores (plural  nouns) for tables, and lower case letters with underscores (singular  nouns) for database and columns.

The thing is, just choose one convenient way for you, and stick to it.



# Entity Relationship Diagram

An entity relationship model, also called an entity-relationship (ER)  diagram, is a graphical representation of entities (which will become  your tables) and their relationships to each other.

## Entity

A simple rectangular block represents a table.

## Relationship

It’s sketched using the diamond shape.

![Image for post](https://miro.medium.com/max/426/1*Rqfo5HvRZ9LU7VTAlZzGJw.png)

You can sketch the type of the relationship, whether one-to-many using  “1-M” , or many-to-many using “M-N”, or one-to-one using “1–1”.

The lines connecting an entity with a relationship whether single or double line refer to another constrain (we talked about earlier) called  “Existence Dependency Constraint” (also called “Participation  Constraint”).

So, for example, if an employee **must** work for a department, this sketched by double lines, and called “total or mandatory participation”. And if an employee **may or may not** manage a department, this is sketched by a single line and called “partial or optional participation”.

> A relationship itself can have attributes. In which table we will include these attributes will be discussed in [Database Mapping](https://medium.com/omarelgabrys-blog/af029e93cc1f) in the next tutorial.

## Recursive Relationship

It’s a relationship with the the same entity. For example, an employee may act as a *supervisor* for one or more employees, while an employee may be *supervised by* an employee (it’s one-to-many relationship).

![Image for post](https://miro.medium.com/max/268/1*Sgvyhct6EFT-fpuowYGhTA.png)

## Weak Entity

A weak entity is simply an entity where it’s existence depends on another entity. You can’t logically have dependent(son, daughter, ..etc.) with  the absence of the employee table. It’s sketched same as a normal entity but wit double lines.

## Partial Key

A weak entity has what’s called a “partial key”. It’s one or more  attributes that uniquely identify a weak entity for a given owner  entity. In our example, the dependent *name* is unique for every employee.

It’s sketched the same as a normal attribute, but, with dashed underline.

> It’s called partial because it can’t be a primary key on it’s own, it needs  another column, which is the foreign key of the owner entity. This will  be discussed in [Database Mapping](https://medium.com/omarelgabrys-blog/af029e93cc1f) in the next tutorial.

## Weak Entity Relationship

Also whenever there is a relationship between a weak entity and another  entity, it’s sketched same as the one above, but with double lines.

![Image for post](https://miro.medium.com/max/283/1*49CmicjMoo9NHvkRd8Dteg.png)

## Attribute

An attribute or a column (simple) represents a piece of data in the table, like an address, salary, and date.

![Image for post](https://miro.medium.com/max/75/1*y2YKmul4C2CFD29jWjtLqQ.png)

## Primary Key

It’s sketched the same as a normal attribute, but, with underline.

![Image for post](https://miro.medium.com/max/145/1*YswELZxI0PLEchB-IW99rA.png)

## Composite Attribute

A value that composed of some other values, for example, you may have name that’s composed of ( *first name, middle name,* and *last name*).![Image for post](https://miro.medium.com/max/256/1*frChDQK5ma0LVgTTVH8Lww.png)

We don’t define one column for name (if it’s [composite](https://medium.com/omarelgabrys-blog/database-fundamentals-part-2-b841032243ac)), instead we split it up into simple separate columns; first name, last  name. One reason is because you may do something different with the last name(or first name), and you want to get to it by itself. This will be  discussed in [Database Mapping](https://medium.com/omarelgabrys-blog/af029e93cc1f) in the next tutorial.

## Derived Attribute

When you have a column where it’s value could be calculated from another  column. Thus, there is no need to insert it’s value every time. For  example, we can know the number of employees work on a specific  department by counting the number of rows.

![Image for post](https://miro.medium.com/max/60/1*jl3AH0XzvRhUkfbFwWGLZw.png?q=20)

![Image for post](https://miro.medium.com/max/215/1*jl3AH0XzvRhUkfbFwWGLZw.png)



This will be done automatically by the DBMS, and it will lead to having a  consistent values rather than accidentally inserting a wrong value.

# Symbols Summary

Here is a summary for all the symbols in the ERD.

![Image for post](https://miro.medium.com/max/408/1*IlYAXlnKxFsTCVrsjyyu_A.jpeg)

# Logical Design

## 1. Mapping of Regular Entity Types

For each entity, create a table that includes all of it’s simple  attributes. Then, choose the primary key, if it’s composite, then a set  of simple attributes will form together the primary key.

> The composite column will be decomposed into separate simple columns.

## 2. Mapping of Weak Entity Types

For each weak entity, create a table that includes all of it’s simple  attributes. And include a foreign key points to the primary key of the  owner entity, where the foreign key and partial key will be the primary  key of the weak entity.

> A [partial key](https://medium.com/omarelgabrys-blog/database-modeling-entity-relationship-diagram-part-5-352c5a8859e5) uniquely identify a weak entity for a given owner entity.

## 3. Mapping of 1:1 Relationship Types

There are three ways:

1. **Foreign Key approach**: Choose the primary key from either one of the entities, and make  foreign key in the other entity referencing the primary key of the first one.
2. **Merged relation option**: Merge both entities, since every row in any entity will have only corresponding row in the other entity.
3. **Cross-reference or relationship relation option**: Create a third table, that has two foreign keys from the primary keys of both entities (overkill!).

## 4. Mapping of 1:M Relationship Types

Considering the example we have been using, where each employee *works for* only one departments, while a department can have more than one employee.

Now, in order to map this relationship, we add a foreign key in the employee table (many side), which in turn will point to the primary key of the  department table (1 side).

## Recursive Relationship

Don’t let the recursive relationship trick you!. You would treat it like any other relationship between one entity and another.

In our example, we had a one-to-many recursive relationship called *supervision* between the employee entity and itself.

> In other cases, you may have a many-to-many recursive relationship, or something else.

The same thing goes here, just add a foreign key in the many side (which is the employee table), which points to the primary key of the 1 side  (which is also the employee table).

![Image for post](https://miro.medium.com/max/776/1*jGAr7kS5LdvVDQ_VIvt3sw.png)



Now, if an employee is *supervised by* another employee, *SUPERSSN* will be assigned to the *supervisor* employee’s id. Otherwise, it’s given null.

## More About Foreign Keys

- Foreign key’s values must exist in the primary key at any time. That’s it, a  foreign key can’t have a value that’s not in the primary key it refers  to.
- Foreign key can have different values, and could be not unique.
- Foreign key may be primary key but, one foreign key can’t be, two foreign keys can; composite primary keys.
- Foreign key may have different name from primary key.
- Foreign key’s data type must match with data type of the primary key.
- Foreign key may contain *NULL* (based on rules defined by the user).

## 5. Mapping of M:N Relationship Types

A good example for this relationship, is every employee can *work on* one or more project, and every project can have one or more employee involved in this project. So, it’s many from both sides.

Now, in order to map this relationship, we create a new table, this table  exists only to connect the employee and project tables. You start by  adding two foreign keys, each one will point to a primary key of one of  the two tables. The two foreign keys together will form the primary key  of the new table.

There may be an employee called *Adam* who works on *Project A*, and *Project B*. And another employee who’s working on *Project A*. But, you can’t have duplicates; meaning, you can’t have two rows with the same employee, and the same project.

![Image for post](https://miro.medium.com/max/679/1*EgH7kZLb7F7c_MVkAimQ1g.png)

## 6. Mapping of Multi-valued Attributes

Remember? A multi-valued attribute is a set of different values.

As an example, a department may have different locations, thus it will have different location values for each department.

So, we create a new table that has a foreign key points to the primary key  of department, and another column represent the multi-valued attribute  (one-to-many relationship). This is done for each multi-valued  attribute.

The foreign key and the multi-valued attribute together will form the primary key of the new table.

![Image for post](https://miro.medium.com/max/533/1*c0frZHbqMn61U1e5m564pg.png)

## 7. Mapping of N-ary Relationship Types

*“What if you have a relationship that connects more than two tables?*”. It’s almost the same solution as we did in M:N relationship.

Create a new table, that has the foreign keys from the primary keys of all  participating entities, the foreign keys together will form the primary  keys of the new entity. Also include any simple attribute of that  relationship in the new table.

## Relational Integrity Constraints

There are some constrains [we can define](https://medium.com/omarelgabrys-blog/database-structured-query-language-part-8-230a1808ec96) and they are enforced by the DBMS to keep your data valid and  meaningful across all of your tables. There are three main constrains:

1. **Unique Key Constraints:** A unique column or a group of columns that uniquely identify each row can’t be duplicated (although they could be *null*).
2. **Entity Integrity Constraints:** A primary key is uniquely identify each row, can’t be duplicated, and can’t take *null*.
3. **Referential Integrity Constraints:** A foreign key … (see [above](https://medium.com/omarelgabrys-blog/database-modeling-logical-design-part-6-af029e93cc1f)).

> Deleting rows from the M-side table in one-to-many relationship, or, deleting  rows from the linking tables in many-to-may relationship **doesn’t** violate the referential integrity constraint.

# Normalization

This is a process where you take your database design, and you apply a set  of formal criteria of rules called “Normal Forms”. And we step through  them first normal form, second normal form, and third normal form.

You usually will end up creating a few new tables as part of the process.  But, the end result of normalization is to make your database easier to  edit, easier to maintain, and preform operations, remove any duplicates, & more reliable to work with.

## First Normal Form

First normal form requires that every column should have one, and only one  value; there is no multi-valued attribute, and there shouldn’t be  repeating groups of data.

So, for example, if you have a customer, and this customer can have two  emails; the main email and the alternative one. Now, you can just put  two columns in your table, each column represent on of these emails  (repeating group ☹).

Alternatively, you can have two rows for this customer, one with the main email, and  the other row with the alternative email, while keeping the other  columns’ values as they are (repeating group ☹).

But, “*What if you want to extend this, and add more emails?*”. We don’t want to have a table that has repeating group of data.

So, what are going to do is to extract the customer emails in a new table.  This new table will have a foreign key points to the primary key of the  original table, and another column for the email values. Both the  foreign key and the email value are together form the primary key of the new table.

## Second Normal Form

The problem arise when you have a composite primary key in a table. The second normal form requires that all of the non-*primary* columns have to be dependent on the entire (composite) primary key.

An example could be, let’s say you have a table that stores books  information. A book could have a name, author, and date released.

According to the requirements, we can have book that’s written by more than one  author, but we can’t have more than one book with the same book name and the same author. So, both name and author form a composite primary key.

![Image for post](https://miro.medium.com/max/724/1*ly9KZosrCn3vH3nInBqaUA.png)

Now, the date column relies only on the name of the book, it doesn’t care  about who wrote this book, it cares about the name of the book. And if  you noticed we’ve written the date “2011” more than one time with  “Database Systems” book. This is not a good practice when you have  duplicates.

So, what we are going to do is to create a separate table, with one-to-many relationship with the original table, it has the book name as a primary key, and all the dependent attributes (like date).

Now, the book name in the book table is a foreign key that points to the  primary key of the new created table, and every non-primary column in  the book table (if exist) depends on the whole composite primary key;  name and author, and not one of them.

![Image for post](https://miro.medium.com/max/585/1*szIDbh2PvC2C97aGhRS-VQ.png)

## Third Normal Form

The third normal form is concerned with the non-key attribute that rely on another non-key attributes, and not the primary key.

An example for that could be with the course table, where every course has an name as a primary key, room number and capacity.

![Image for post](https://miro.medium.com/max/598/1*JZrrIKm60eJFlNdBkfbnjA.png)

Now, it’s obviously noted that the capacity depends on the room, it has  nothing to do with the course name. This means we have a non-key  attribute that depends on another non-key attribute.

Why this sounds like a problem? Well*, “What happens if somebody reached into this table, and they changed  that room for a specific course, but they didn’t change the capacity?”.*

So, what we are going to do is the same, we will create a new table with  one-to-many relationship with the original table, it has the room number as a primary key, and all the dependent attributes like the capacity.

Now, the room number in the course table is a foreign key that points to the primary key of the new created table.

![Image for post](https://miro.medium.com/max/546/1*r8U13nDqlKihfAKj23faaQ.png)

## Derived Attribute

Another example of third normal form is when you have a (non-primary) [derived](https://medium.com/omarelgabrys-blog/database-modeling-entity-relationship-diagram-part-5-352c5a8859e5) attribute that depends on other non-primary attributes.

We would remove that derived column form this table, as we can figure it  out when we need to. One of the main reasons for this is to prevent any  conflicts, any inaccurate data to be inserted mistakenly.

Many database systems offer you the option of defining a computed or  calculated column. It’s not actually stored in the database, it is a  convenient read-only fiction. It’s value is automatically calculated  based on the other columns in the table, and you may find that useful  from time to time.

## Denormalization

Sometimes you will hit the situation where you will break the normalization rules for performance improvements, because normalization is often involves  splitting data into multiple tables.

If you are following along, you remember at the first normal form, when we explained the example of emails. *“What happens if we added two email columns to the customer table?.”*

Technically, this can be described as breaking first normal form. It’s a repeating  group. But in practice, you may find it more convenient to just allow an *email1* and *email2* columns, because you’re sure there won’t be a flexible number of email addresses.

# Indexing

One of the ways that will optimize your database searching and accessing is having indexes on the columns that you usually access the table using  it.

What the DBMS will do when you ask for a specific row, it will go sequentially and check with every row; “*Is this the row that I need?*”, If yes return it, if no, keep searching till the end.

But, we have a better way to do that. An index, as we’ve mentioned, is a  data structure, it won’t be obvious for you, but it’s stored inside the  DBMS, most commonly as a B- tree.

> By default, Most of the DBMS automatically create an index on primary and unique columns.

## How Indexes Work?

Let’s say that you have an index for a primary key. This will create an  ordered list of primary key values in a separate table, each entry has a pointer points to the relative value in the original table.

So, whenever you want to access a table using the primary key, it will use  binary search algorithm (takes time of O(LogN)) to access the required  value in the Index table, and then, go to the relative value in the  original table.

![Image for post](https://miro.medium.com/max/942/1*VD4JpCxtVEZ1sN8DVZ33ow.png)

And, definitely, you can create another index on another column, even if it’s a non-primary column, like *first name*, assuming that you usually access the table using that column.

The decision for choosing another column (besides the primary key) to be  indexed-ed can be delayed until the database has been used for a while.  This is because we want to know how users are really using our database, and what kind of queries they’re running rather than how we hoped or  thought.

## Clustered & Non-Clustered Indexes (Optional)

Some DBMS has different implementation of indexes. They use the idea of *clustered* & *non-clustered* index.

![Image for post](https://miro.medium.com/max/962/1*zVRuW_ojCT96tFENhDMJwA.png)

## Clustered Index

Every table can have one and only one clustered index. The most common  clustered index in any database table is the primary key column.

The database will then order the data in the table based on the clustered  index; no Index table need to be created. The binary search algorithm  will be used to get to the required data in the table (already ordered).

## — Non-Clustered Indexes

If you found yourself often also accessing the data using another column,  we can create a secondary index; a non-clustered index.

Let’s say we want to create a secondary index for the *last name,* while the clustered index is the *employee id.* It’s created in a separate table, it has two columns, one for the last name, and one for the corresponding *employee id*.

The created table is now sorted by *last name*, the way that we can’t actually do in the employee table, because we’re already sorted by the *employee id*.

Now it’s not as quick as using the clustered index. *Why?* We still need to read from the table created for secondary index then jump to the employee table to get to a specific employee. But, it’s much  quicker than a full table scan.

> A table can have only one clustered index, while it can have more than one non-clustered index.

## Indexes Pitfalls

Indexes are a great way to optimize the performance, but you don’t have to put index on every column.

Yes, it’s much quicker than the sequential search, but, they must be  maintained. If your column changes a lot in your original table, keep in mind that every update, or insert, or even delete has to reflect back  on the Index table. In addition, since every index is a new table, it  requires additional space.

So, the moral of the story, indexes will improve the performance, use them on the columns that you will access a lot.

# Transactions

A transaction is a combination or a set of queries. There are 4  properties for any transaction that must be fulfilled, grouped together  under the acronym *ACID.* So, a transaction must be ***Atomic*, *Consistent*, *Isolated*, and *Durable*.**

## Atomic

It’ says that a transaction either gonna successfully executed or not at  all, and so the database has to revert back to the original state in  case of failure.

So, if a transaction has 20 queries, and you executed them all successfully except the last one, the database has to revert back to the original  state; the state before executing the transaction.

This is because a transaction is a one unit, either successfully executed or not at all.

## Consistent

A transaction must take the database from one valid state to another  valid state. So, for example if you have a foreign key that references a primary key, and you accidentally deleted a primary key, this will  violate the integrity constrains, because a foreign key can’t reference a value that doesn’t exist.

So, even if a transaction is successfully atomic, it still can’t result in a situation that violates any of the integrity rules defined in a  database.

## Isolation

Consider that we have two persons *John* and *Peter*, and they accessing the same bank account at the same time from different places. So, the first transaction by *John* will start by selecting the balance of account number *2100*, and so the second by *Peter*.

![Image for post](https://miro.medium.com/max/864/1*gQcduP1m767a7L1XWhQOFA.png)

And, because they want to withdraw *$100*, they will decrement *100$* from *1000$,* and the balance will be updated to *900$*. Now, the balance is *900$*, although we withdraw *200$* (*100$* for *John*, and *100$* for *Peter*). Obviously, this is not a good situation for the bank.

![Image for post](https://miro.medium.com/max/777/1*GSaTu1BdRGeZTIhHEELV8A.png)

So, Isolation will isolate the data, and transactions won’t interfere with  each other. And, if a transaction is trying to change a row, this row  won’t be available for any other transaction unless the first  transaction finishes.

> Now, concurrency control in transactions is one of the areas where it’s  implemented differently across database management systems, although the principles are the same. So, take a look at your chosen database  management system when it comes time to do this.

## Durable

Durability refers to the transaction being considered robust. It means if a  transaction is successfully committed, then the transaction is  guaranteed. So, if we changed the balance successfully, then the new  balance will remain, even if the system crashes later or there was a  power failure.

Many DBMSs write transactions into a transaction log. This will maintain the last state of the system.